"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const path = require("path");
const mkdirpCallback = require("mkdirp");
const fs_1 = require("fs");
const ncp_1 = require("ncp");
const rimrafCallback = require("rimraf");
const util_1 = require("util");
const configManager_1 = require("./../configManager");
const spinner = require("./../cli/logIndicator");
const gitignoreManager_1 = require("../gitignoreManager");
const exists = util_1.promisify(fs_1.exists);
const mkdirp = util_1.promisify(mkdirpCallback);
const writeFile = util_1.promisify(fs_1.writeFile);
const readFile = util_1.promisify(fs_1.readFile);
const readdir = util_1.promisify(fs_1.readdir);
const rimraf = util_1.promisify(rimrafCallback);
const ncp = util_1.promisify(ncp_1.ncp);
/** Default encoding */
const ENCODING = 'utf8';
/** Recommended Lamington package scripts */
const DEFAULT_SCRIPTS = {
    build: 'lamington build',
    test: 'lamington test',
};
/** Required project dependencies */
const DEFAULT_DEV_DEPENDENCIES = {
    'lamington': 'latest',
    'chai': 'latest',
    '@types/chai': 'latest',
    '@types/mocha': 'latest'
};
/**
 * Fetches and stores the latest EOS configuration images
 * @author Mitch Pierias <github.com/MitchPierias>
 */
class ProjectManager {
    /**
     * Downloads the example project and integrates aspects where required.
     * @author Mitch Pierias <github.com/MitchPierias>
     */
    static initWithDefaults() {
        return __awaiter(this, void 0, void 0, function* () {
            yield ProjectManager.cloneExampleProject();
            yield ProjectManager.loadExistingProject();
            yield ProjectManager.injectScripts();
            yield ProjectManager.configureDependencies();
            yield ProjectManager.createDirectoryIfMissing('.lamington');
            yield writeFile(path.join(process.cwd(), 'package.json'), JSON.stringify(ProjectManager.cache, null, 4), ENCODING);
            yield configManager_1.ConfigManager.createConfigIfMissing();
            yield gitignoreManager_1.GitIgnoreManager.createIfMissing();
        });
    }
    /**
     * Examines the current directory and loads any existing `package.json` file
     * into this object cache state.
     * @author Mitch Pierias <github.com/MitchPierias>
     * @hidden
     */
    static loadExistingProject() {
        return __awaiter(this, void 0, void 0, function* () {
            let packageJson = '';
            try {
                packageJson = yield readFile(path.join(process.cwd(), 'package.json'), ENCODING);
            }
            catch (error) {
                console.error();
                console.error(colors.red('Could not read project package.json file in this folder. Is this a node project folder?'));
                console.error();
                process.exit(1);
            }
            ProjectManager.cache = JSON.parse(packageJson);
        });
    }
    /**
     * Injects recommended Lamington scripts into the currently cached package data
     * @author Mitch Pierias <github.com/MitchPierias>
     * @hidden
     */
    static injectScripts() {
        return __awaiter(this, void 0, void 0, function* () {
            spinner.create('Injecting recommended scripts');
            const existingScripts = ProjectManager.cache.scripts || {};
            ProjectManager.cache.scripts = Object.assign(Object.assign({}, existingScripts), DEFAULT_SCRIPTS);
            spinner.end('Added recommended scripts');
        });
    }
    /**
     * Injects the required project dependencies into the currently cached package data
     * @author Mitch Pierias <github.com/MitchPierias>
     * @hidden
     */
    static configureDependencies() {
        return __awaiter(this, void 0, void 0, function* () {
            spinner.create('Adding Lamington dependencies');
            const existingDependencies = ProjectManager.cache.devDependencies || {};
            ProjectManager.cache.devDependencies = Object.assign(Object.assign({}, DEFAULT_DEV_DEPENDENCIES), existingDependencies);
            spinner.end('Added required dependencies');
        });
    }
    /**
     * Downloads the latest example Lamington project from GitHub
     * @author Mitch Pierias <github.com/MitchPierias>
     * @hidden
     */
    static cloneExampleProject() {
        return __awaiter(this, void 0, void 0, function* () {
            // Notify cloning task begun
            spinner.create('Pulling example project');
            // Check for existing contract files
            yield ProjectManager.createDirectoryIfMissing('contracts');
            const files = yield readdir(path.join(process.cwd(), 'contracts'));
            if (files.length > 0)
                return spinner.end('Existing contracts found');
            // Attempt clone and merge of example project
            try {
                const got = require('got');
                const tar = require('tar');
                const cloneUrl = `https://codeload.github.com/MitchPierias/EOSIO-Lamington-Boilerplate/tar.gz/master`;
                spinner.update('Cloning example project');
                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    // Ensure tmp directory exists and capture directory path
                    const tmpPath = yield ProjectManager.createDirectoryIfMissing('__tmp__');
                    // Stream the repo clone and untar
                    got.stream(cloneUrl).pipe(tar.extract({
                        cwd: tmpPath,
                        strip: 1
                    })).on('error', (error) => {
                        reject(error);
                    }).on('end', () => __awaiter(this, void 0, void 0, function* () {
                        // Clone example repository into tmp
                        const clonedFiles = yield readdir(tmpPath);
                        if (clonedFiles.length <= 0)
                            throw new Error(`No files cloned from repo ${cloneUrl}`);
                        // Merge example contracts into current project
                        yield ncp(path.join(tmpPath, 'contracts'), path.join(process.cwd(), 'contracts'));
                        // Cleanup temporary directory
                        spinner.update('Cleaning temporary files');
                        yield rimraf(tmpPath);
                        spinner.end('Created example contracts');
                        resolve(true);
                    }));
                }));
            }
            catch (error) {
                spinner.fail('Failed to clone repository');
                console.log(error);
            }
        });
    }
    /**
     * Creates a new local directory if missing and returns the path
     * @author Mitch Pierias <github.com/MitchPierias>
     * @param dirName Directory to create
     * @returns Path to local directory
     * @private
     */
    static createDirectoryIfMissing(dirName) {
        return __awaiter(this, void 0, void 0, function* () {
            // Construct directory path
            const dirPath = path.join(process.cwd(), dirName);
            // Create directory if missing
            if (!(yield exists(dirPath)))
                yield mkdirp(path.join(process.cwd(), dirName));
            // Return the directory name
            return dirPath;
        });
    }
}
exports.ProjectManager = ProjectManager;

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const mkdirpCallback = require("mkdirp");
const fs_1 = require("fs");
const util_1 = require("util");
const exists = util_1.promisify(fs_1.exists);
const mkdirp = util_1.promisify(mkdirpCallback);
const writeFile = util_1.promisify(fs_1.writeFile);
const readFile = util_1.promisify(fs_1.readFile);
/** @hidden Root config directory path */
const CACHE_DIRECTORY = '.lamington';
/** @hidden Default encoding */
const ENCODING = 'utf8';
/** @hidden Configuration file name */
const CONFIGURATION_FILE_NAME = '.lamingtonrc';
/** Level of debug output */
var LamingtonDebugLevel;
(function (LamingtonDebugLevel) {
    LamingtonDebugLevel[LamingtonDebugLevel["NONE"] = 0] = "NONE";
    LamingtonDebugLevel[LamingtonDebugLevel["TRANSACTIONS"] = 1] = "TRANSACTIONS";
    LamingtonDebugLevel[LamingtonDebugLevel["ALL"] = 2] = "ALL";
})(LamingtonDebugLevel = exports.LamingtonDebugLevel || (exports.LamingtonDebugLevel = {}));
/**
 * Default configuration values which are merged in
 * as the base layer config. Users can override these
 * values by specifying them in their `.lamingtonrc`
 */
const DEFAULT_CONFIG = {
    eos: '',
    cdt: '',
    debug: LamingtonDebugLevel.NONE,
    debugTransactions: false,
    keepAlive: false,
    outDir: CACHE_DIRECTORY,
    exclude: [],
};
/**
 * Manages Lamington configuration setup and caching
 */
class ConfigManager {
    /**
     * Initialize application configuration using the user
     * defined configurations and defaults
     * @author Kevin Brown <github.com/thekevinbrown>
     * @author Mitch Pierias <github.com/MitchPierias>
     */
    static initWithDefaults() {
        return __awaiter(this, void 0, void 0, function* () {
            DEFAULT_CONFIG.cdt = yield ConfigManager.getAssetURL('EOSIO', 'eosio.cdt', 'amd64.deb');
            DEFAULT_CONFIG.eos = yield ConfigManager.getAssetURL('EOSIO', 'eos', 'ubuntu-18.04');
            if (!(yield ConfigManager.configExists())) {
                console.log('Project has not yet been initialized.');
                console.log('Please run lamington init before running this command.');
                process.exit(1);
            }
            yield ConfigManager.loadConfigFromDisk();
        });
    }
    /**
     * Downloads the organization's latest repository release image and
     * returns the assets matching the specified filter
     * @author Kevin Brown <github.com/thekevinbrown>
     * @param organization Asset's case-sensitive repository organization
     * @param repository Asset's case-sensitive repository name
     * @param filter Resource filter
     * @hidden
     */
    static getAssetURL(organization, repository, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get the projects latest GitHub repository release
            const result = yield axios_1.default.get(`https://api.github.com/repos/${organization}/${repository}/releases/latest`);
            // Handle failed GitHub request
            if (!result.data || !result.data.assets || !Array.isArray(result.data.assets)) {
                console.error(result);
                throw new Error('Unexpected response from GitHub API. Please try again later.');
            }
            // Capture the GitHub url from response
            const asset = result.data.assets.find((asset) => asset.browser_download_url.includes(filter));
            // Handle no assets found
            if (!asset)
                throw new Error(`Could not locate asset with ${filter} in the download URL in the ${organization}/${repository} repository`);
            // Return captured download url
            return asset.browser_download_url;
        });
    }
    static isValidConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    /**
     * Creates a default configuration file if it doesn't exist at the specified path.
     * @author Mitch Pierias <github.com/MitchPierias>
     * @author Kevin Brown <github.com/thekevinbrown>
     * @param atPath Optional configuration file path. Defaults to `.lamingtonrc`.
     */
    static createConfigIfMissing(atPath = CONFIGURATION_FILE_NAME) {
        return __awaiter(this, void 0, void 0, function* () {
            // Prevent overwriting existing configuration when valid
            if ((yield ConfigManager.configExists(atPath)) && (yield ConfigManager.isValidConfig(ConfigManager.config)))
                return;
            // Create the config directory
            yield mkdirp(CACHE_DIRECTORY);
            // Fetch the latest repository configuration
            const defaultConfig = Object.assign({ cdt: yield ConfigManager.getAssetURL('EOSIO', 'eosio.cdt', 'amd64.deb'), eos: yield ConfigManager.getAssetURL('EOSIO', 'eos', 'ubuntu-18.04') }, DEFAULT_CONFIG);
            // Cache the configuration file to disk
            yield writeFile(atPath, JSON.stringify(defaultConfig, null, 4), ENCODING);
        });
    }
    /**
     * Checks the existence of the configuration
     * file at the default [[CONFIGURATION_FILE_NAME]] or
     * optional path
     * @author Mitch Pierias <github.com/MitchPierias>
     * @param atPath Optional file path for lookup
     * @returns Config exists determiner
     */
    static configExists(atPath = CONFIGURATION_FILE_NAME) {
        // Should filter out any trailing filename and concatonate
        // the default filename
        return exists(atPath);
    }
    /**
     * Loads an existing configuration file into [[ConfigManager.config]]
     * @author Kevin Brown <github.com/thekevinbrown>
     * @param atPath Optional file path for lookup
     */
    static loadConfigFromDisk(atPath = CONFIGURATION_FILE_NAME) {
        return __awaiter(this, void 0, void 0, function* () {
            // Read existing configuration and store
            ConfigManager.config = Object.assign(Object.assign({}, DEFAULT_CONFIG), JSON.parse(yield readFile(atPath, ENCODING)));
        });
    }
    /**
     * Returns the current EOSIO configuration
     * @author Kevin Brown <github.com/thekevinbrown>
     */
    static get eos() {
        return (ConfigManager.config && ConfigManager.config.eos) || '';
    }
    /**
     * Returns the current EOSIO.CDT configuration
     * @author Kevin Brown <github.com/thekevinbrown>
     */
    static get cdt() {
        return (ConfigManager.config && ConfigManager.config.cdt) || '';
    }
    /**
     * Returns the container keep alive setting or false
     * @author Mitch Pierias <github.com/MitchPierias>
     */
    static get keepAlive() {
        return (ConfigManager.config && ConfigManager.config.keepAlive) || DEFAULT_CONFIG.keepAlive;
    }
    /**
     * Returns the container's debug log output setting
     * @author Kevin Brown <github.com/thekevinbrown>
     */
    static get debugTransactions() {
        return ((ConfigManager.config && ConfigManager.config.debugTransactions) ||
            DEFAULT_CONFIG.debugTransactions);
    }
    /**
     * Returns the output build directory or [[CACHE_DIRECTORY]]
     * @author Mitch Pierias <github.com/MitchPierias>
     */
    static get outDir() {
        return (ConfigManager.config && ConfigManager.config.outDir) || DEFAULT_CONFIG.outDir;
    }
    /**
     * Returns the array of excluded strings or patterns
     * @author Mitch Pierias <github.com/MitchPierias>
     */
    static get exclude() {
        return (ConfigManager.config && ConfigManager.config.exclude) || DEFAULT_CONFIG.exclude;
    }
}
exports.ConfigManager = ConfigManager;

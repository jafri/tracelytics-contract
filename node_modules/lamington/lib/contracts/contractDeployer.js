"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs_1 = require("fs");
const util_1 = require("util");
const eosjs_1 = require("eosjs");
const ecc = require("eosjs-ecc");
const exists = util_1.promisify(fs_1.exists);
const readFile = util_1.promisify(fs_1.readFile);
const accounts_1 = require("../accounts");
const eosManager_1 = require("../eosManager");
const configManager_1 = require("../configManager");
const contractLoader_1 = require("./contractLoader");
/**
 * Provides a set of methods to manage contract deployment
 */
class ContractDeployer {
    /**
     * Deploys contract files to a specified account
     *
     * ```typescript
     * // Create a new account
     * const account = await AccountManager.createAccount();
     * // Deploy the contract `mycontract` to the account
     * ContractDeployer.deployToAccount<MyContractTypeDef>('mycontract', account);
     * ```
     * @author Kevin Brown <github.com/thekevinbrown>
     * @param contractIdentifier Contract identifier, typically the contract filename minus the extension
     * @param account Account to apply contract code
     * @returns Deployed contract instance
     */
    static deployToAccount(contractIdentifier, account) {
        return __awaiter(this, void 0, void 0, function* () {
            eosManager_1.EOSManager.addSigningAccountIfMissing(account);
            // Initialize the serialization buffer
            const buffer = new eosjs_1.Serialize.SerialBuffer({
                textEncoder: eosManager_1.EOSManager.api.textEncoder,
                textDecoder: eosManager_1.EOSManager.api.textDecoder,
            });
            // Construct resource paths
            const abiPath = path.join(configManager_1.ConfigManager.outDir, 'compiled_contracts', `${contractIdentifier}.abi`);
            if (!(yield exists(abiPath))) {
                throw new Error(`Couldn't find ABI at ${abiPath}. Are you sure you used the correct contract identifier?`);
            }
            const wasmPath = path.join(configManager_1.ConfigManager.outDir, 'compiled_contracts', `${contractIdentifier}.wasm`);
            if (!(yield exists(wasmPath))) {
                throw new Error(`Couldn't find WASM file at ${wasmPath}. Are you sure you used the correct contract identifier?`);
            }
            // Read resources files for paths
            let abi = JSON.parse(yield readFile(abiPath, 'utf8'));
            const wasm = yield readFile(wasmPath);
            // Extract ABI types
            const abiDefinition = eosManager_1.EOSManager.api.abiTypes.get(`abi_def`);
            // Validate ABI definitions returned
            if (!abiDefinition)
                throw new Error('Could not retrieve abiDefinition from EOS API when flattening ABIs.');
            // Ensure ABI contains all fields from `abiDefinition.fields`
            abi = abiDefinition.fields.reduce((acc, { name: fieldName }) => Object.assign(acc, { [fieldName]: acc[fieldName] || [] }), abi);
            // Serialize ABI type definitions
            abiDefinition.serialize(buffer, abi);
            // Set the contract code for the account
            yield eosManager_1.EOSManager.transact({
                actions: [
                    {
                        account: 'eosio',
                        name: 'setcode',
                        authorization: account.active,
                        data: {
                            account: account.name,
                            vmtype: 0,
                            vmversion: 0,
                            code: wasm.toString('hex'),
                        },
                    },
                    {
                        account: 'eosio',
                        name: 'setabi',
                        authorization: account.active,
                        data: {
                            account: account.name,
                            abi: Buffer.from(buffer.asUint8Array()).toString(`hex`),
                        },
                    },
                ],
            });
            return yield contractLoader_1.ContractLoader.at(account);
        });
    }
    /**
     * Deploys contract files to a randomly generated account
     *
     * ```typescript
     * // Deploy the contract with identifier
     * ContractDeployer.deploy<MyContractTypeDef>('mycontract');
     * ```
     *
     * @author Kevin Brown <github.com/thekevinbrown>
     * @param contractIdentifier Contract identifier, typically the contract filename minus the extension
     * @returns Deployed contract instance
     */
    static deploy(contractIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            // Create a new account
            const account = yield accounts_1.AccountManager.createAccount();
            // Call the deployToAccount method with the account
            return yield ContractDeployer.deployToAccount(contractIdentifier, account);
        });
    }
    /**
     * Deploys contract files to a specified account name
     *
     * ```typescript
     * // Deploy the `mycontract` contract to the account with name `mycontractname`
     * ContractDeployer.deployWithName<MyContractTypeDef>('mycontract', 'mycontractname');
     * ```
     *
     * @note Generating a pseudorandom private key is not safe in the cryptographic sense. It can be used for testing.
     * @author Mitch Pierias <github.com/MitchPierias>
     * @param contractIdentifier Contract identifier, typically the contract filename minus the extension
     * @param accountName Account name
     * @returns Deployed contract instance
     */
    static deployWithName(contractIdentifier, accountName) {
        return __awaiter(this, void 0, void 0, function* () {
            // Generate a random private key
            const privateKey = yield ecc.unsafeRandomKey();
            // Initialize account with name
            const account = new accounts_1.Account(accountName, privateKey);
            yield accounts_1.AccountManager.setupAccount(account);
            // Call the deployToAccount method with the account
            return yield ContractDeployer.deployToAccount(contractIdentifier, account);
        });
    }
}
exports.ContractDeployer = ContractDeployer;

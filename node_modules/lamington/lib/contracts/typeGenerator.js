"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const globWithCallbacks = require("glob");
const fs = require("fs");
const path = require("path");
const util_1 = require("util");
const typeMap_1 = require("./typeMap");
const configManager_1 = require("../configManager");
const utils_1 = require("./utils");
const glob = util_1.promisify(globWithCallbacks);
/**
 * Parses a C++ type definition into a Typescript definition
 * @author Kevin Brown <github.com/thekevinbrown>
 * @author Mitch Pierias <github.com/MitchPierias>
 * @param eosType
 */
exports.mapParameterType = (eosType) => {
    // Handle array types
    const wrapper = eosType.endsWith('[]') ? 'Array' : undefined;
    const type = typeMap_1.default[eosType.replace('[]', '')] || 'string';
    if (wrapper) {
        return `${wrapper}<${type}>`;
    }
    else {
        return type;
    }
};
/**
 * Loads all `.abi` files and generates types
 * @author Kevin Brown <github.com/thekevinbrown>
 */
exports.generateAllTypes = () => __awaiter(void 0, void 0, void 0, function* () {
    // Load all `.abi` files
    const files = yield glob('**/*.abi');
    // Handle no files found
    if (files.length === 0)
        throw new Error('No ABI files to generate from. Exiting.');
    // Generate types for each file
    for (const file of files)
        yield exports.generateTypes(file);
});
/**
 * Generates a Typescript definition file from a contract ABI file
 * @author Kevin Brown <github.com/thekevinbrown>
 * @author Mitch Pierias <github.com/MitchPierias>
 * @param contractIdentifier Path to file without extension
 */
exports.generateTypes = (contractIdentifier) => __awaiter(void 0, void 0, void 0, function* () {
    // Create contract details
    const contractName = path.basename(contractIdentifier);
    const abiPath = path.join(configManager_1.ConfigManager.outDir, 'compiled_contracts', `${contractIdentifier}.abi`);
    // Handle ABI file loading
    if (!fs.existsSync(path.resolve(abiPath)))
        throw new Error(`Missing ABI file at path '${path.resolve(abiPath)}'`);
    const abi = JSON.parse(fs.readFileSync(path.resolve(abiPath), 'utf8'));
    let contractActions = abi.actions;
    let contractTables = abi.tables;
    let contractStructs = Object.assign({}, ...abi.structs.map((struct) => ({ [struct['name']]: struct })));
    // Prepend warning text
    const result = [
        '// =====================================================',
        '// WARNING: GENERATED FILE',
        '//',
        '// Any changes you make will be overwritten by Lamington',
        '// =====================================================',
        '',
    ];
    // Define imports
    const imports = ['Account', 'Contract', 'GetTableRowsOptions'];
    if (contractTables.length > 0)
        imports.push('TableRowsResult');
    // Generate import definitions
    result.push(`import { ${imports.join(', ')} } from 'lamington';`);
    result.push('');
    result.push('// Table row types');
    // Generate table row types from ABI
    for (const table of contractTables) {
        const tableInterface = {
            [`export interface ${utils_1.pascalCase(contractName)}${utils_1.pascalCase(table.name)}`]: contractStructs[table.type].fields.map((field) => `${field.name}: ${exports.mapParameterType(field.type)};`),
        };
        result.push(tableInterface);
        result.push('');
    }
    // Generate contract type from ABI
    const generatedContractActions = contractActions.map((action) => {
        // With a function for each action
        const parameters = contractStructs[action.name].fields.map((parameter) => `${parameter.name}: ${exports.mapParameterType(parameter.type)}`);
        // Optional parameter at the end on every contract method.
        parameters.push('options?: { from?: Account }');
        return `${action.name}(${parameters.join(', ')}): Promise<any>;`;
    });
    // Generate tables
    const generatedTables = contractTables.map((table) => `${utils_1.camelCase(table.name)}(options?: GetTableRowsOptions): Promise<TableRowsResult<${utils_1.pascalCase(contractName)}${utils_1.pascalCase(table.name)}>>;`);
    // Generate the contract interface with actions and tables
    const contractInterface = {
        [`export interface ${utils_1.pascalCase(contractName)} extends Contract`]: [
            '// Actions',
            ...generatedContractActions,
            '',
            '// Tables',
            ...generatedTables,
        ],
    };
    // Cache contract result
    result.push(contractInterface);
    result.push('');
    // Save generated contract
    yield saveInterface(contractIdentifier, result);
});
/**
 * Writes the contract interface to file
 * @author Kevin Brown <github.com/thekevinbrown>
 * @param contractIdentifier Path to file without extension
 * @param interfaceContent Generated contract interface
 */
const saveInterface = (contractIdentifier, interfaceContent) => __awaiter(void 0, void 0, void 0, function* () {
    // Open a write stream to file
    const file = fs.createWriteStream(`${contractIdentifier}.ts`);
    // Write formatted blocks
    let indentLevel = 0;
    const write = (value) => file.write('\t'.repeat(indentLevel) + value + '\n');
    const writeIndented = (level) => {
        for (const outerWrapper of Object.keys(level)) {
            write(`${outerWrapper} {`);
            indentLevel++;
            writeLevel(level[outerWrapper]);
            indentLevel--;
            write('}');
        }
    };
    // Write block content or indent again
    const writeLevel = (level) => {
        if (Array.isArray(level)) {
            for (const entry of level) {
                if (typeof entry === 'string') {
                    write(entry);
                }
                else {
                    writeIndented(entry);
                }
            }
        }
        else {
            writeIndented(level);
        }
    };
    // Write interface to file and close
    writeLevel(interfaceContent);
    file.close();
});

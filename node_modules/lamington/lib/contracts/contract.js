"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const accounts_1 = require("../accounts");
const utils_1 = require("../utils");
const eosManager_1 = require("../eosManager");
const utils_2 = require("./utils");
/**
 * Adds additional functionality to the EOSJS `Contract` class
 */
class Contract {
    constructor({ eos, identifier, account, abi, actions, types }) {
        /** Deployed contract actions */
        this.actions = new Map();
        /** Deployed contract types */
        this.types = new Map();
        /**
         * Retrieves table rows with the specified table name and optional scope
         * @author Kevin Brown <github.com/thekevinbrown>
         * @note Implements a temporary patch for the EOSjs `bool` mapping error
         * @param table The table name
         * @param scope Optional table scope, defaults to the table name
         * @note The original EOSJS typings for this are just `any`. I'd love to improve that.
         */
        this.getTableRows = (table, options) => __awaiter(this, void 0, void 0, function* () {
            // Wait for the next block to appear before we query the values.
            yield utils_1.nextBlock();
            const result = yield this._eos.rpc.get_table_rows({
                code: this.account.name,
                scope: (options && options.scope) || this.account.name,
                table_key: options && options.tableKey,
                lower_bound: options && options.lowerBound,
                upper_bound: options && options.upperBound,
                index_position: options && options.indexPosition,
                key_type: options && options.keyType,
                limit: options && options.limit,
                reverse: options && options.reverse,
                show_payer: options && options.showPayer,
                table,
                json: true,
            });
            // EOSJS gives us values that don't match up with our Typescript types,
            // for example, the ABI bool type gets returned as a number (0 or 1) instead
            // of a boolean. This is confusing and weird when trying to deep equal
            // and other types of comparisons, so we'll go ahead and use the ABI
            // to map the types to what we consider to be more canonical types.
            // This mapping will always be limited to just the types we do special
            // things with in Lamington world, and will always match the generated
            // types for table rows. Other values will pass through untouched.
            const tableAbi = this._abi.tables.find(tableAbi => tableAbi.name === table);
            if (!tableAbi)
                throw new Error(`Could not find ABI for table ${table}`);
            const tableRowType = this.types.get(tableAbi.type);
            if (!tableRowType)
                throw new Error(`Could not find table row type for table ${table}`);
            // Bool is the only type we need to fiddle with at the moment, so only do this if
            // there's a field with a bool type in it.
            const booleanFields = tableRowType.fields.filter(field => field.typeName === 'bool');
            if (booleanFields.length > 0) {
                // Map all `bool` fields from numbers to booleans
                for (const row of result.rows) {
                    for (const field of booleanFields) {
                        const currentValue = row[field.name];
                        if (currentValue !== 0 && currentValue !== 1) {
                            throw new Error(`Invalid value while casting to boolean for ${field.name} field on row. Got ${currentValue}, expected 0 or 1.`);
                        }
                        row[field.name] = currentValue ? true : false;
                    }
                }
            }
            return result;
        });
        /**
         * Grants `eosio.code` permission to the contract account's `active` key
         * @note Can also be called from AccountManager, as the action is technically an account based action.
         * @author Kevin Brown <github.com/thekevinbrown>
         * @author Mitch Pierias <github.com/MitchPierias>
         */
        this.addCodePermission = () => accounts_1.AccountManager.addCodePermission(this._account);
        // Store contract arguments
        this._eos = eos;
        this._identifier = identifier;
        this._account = account;
        this._abi = abi;
        this.actions = actions;
        this.types = types;
        // Set up all the actions as methods on the contract.
        for (const action of actions.values()) {
            this[action.name] = function () {
                const data = {};
                // Copy the params across for the call.
                if (arguments.length < action.fields.length) {
                    throw new Error(`Insufficient arguments supplied to ${action.name}. Expected ${action.fields.length} got ${arguments.length}.`);
                }
                if (arguments.length > action.fields.length + 1) {
                    throw new Error(`Too many arguments supplied to ${action.name}. Expected ${action.fields.length} got ${arguments.length}.`);
                }
                for (let i = 0; i < action.fields.length; i++) {
                    data[action.fields[i].name] = arguments[i];
                }
                // Who are we acting as?
                // We default to sending transactions from the contract account.
                let authorization = account;
                const options = arguments[action.fields.length];
                if (options && options.from && options.from instanceof accounts_1.Account) {
                    authorization = options.from;
                }
                // Ensure we have the key to sign with.
                eosManager_1.EOSManager.addSigningAccountIfMissing(authorization);
                return eosManager_1.EOSManager.transact({
                    actions: [
                        {
                            account: account.name,
                            name: action.name,
                            authorization: authorization.active,
                            data,
                        },
                    ],
                }, eos, { debug: options && options.debug });
            };
        }
        // And now the tables.
        for (const table of abi.tables) {
            this[utils_2.camelCase(table.name)] = function () {
                return this.getTableRows(table.name, arguments[0]);
            };
        }
    }
    /**
     * Gets the currently configured contract account
     * @author Kevin Brown <github.com/thekevinbrown>
     * @returns Current contract account
     */
    get account() {
        return this._account;
    }
    /**
     * Gets the current contract identifier
     * @author Kevin Brown <github.com/thekevinbrown>
     * @returns Contract identifier
     */
    get identifier() {
        return this._identifier;
    }
}
exports.Contract = Contract;

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = require("node-fetch");
const util_1 = require("util");
const eosjs_1 = require("eosjs");
const eosjs_jssig_1 = require("eosjs/dist/eosjs-jssig");
const accounts_1 = require("./accounts");
const configManager_1 = require("./configManager");
const eosjs_numeric_1 = require("eosjs/dist/eosjs-numeric");
/**
 * Manages client connection and communication with a local EOSIO node
 */
class EOSManager {
}
exports.EOSManager = EOSManager;
/**
 * Initializes a default connection to the local EOSIO node on port `8888` and
 * assigns the default `eosio` account with administration keys
 * @author Kevin Brown <github.com/thekevinbrown>
 */
EOSManager.initWithDefaults = () => {
    // Create eosio account and configure signature provider
    // NOTE: This is a known EOS development key used in the EOS docs. It is
    // UNSAFE to use this key on any public network.
    const adminAccount = new accounts_1.Account('eosio', '5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3');
    EOSManager.init({ httpEndpoint: 'http://127.0.0.1:8888', adminAccount });
};
/**
 * Initializes a connection to any EOSIO node and sets the administration keys which
 * Lamington uses to deploy contracts, create accounts, etc.
 * @author Kevin Brown <github.com/thekevinbrown>
 */
EOSManager.init = ({ httpEndpoint, adminAccount, chainId }) => {
    // Create eosio account and configure signature provider
    EOSManager.adminAccount = adminAccount;
    // If we have a key to sign with, go ahead and hook it up.
    if (adminAccount.privateKey) {
        EOSManager.signatureProvider = new eosjs_jssig_1.JsSignatureProvider([adminAccount.privateKey]);
    }
    // Typecasting as any here to prevent a problem with the types disagreeing for fetch,
    // when this is actually following the getting started docs on EOSJS.
    EOSManager.rpc = new eosjs_1.JsonRpc(httpEndpoint, { fetch: node_fetch_1.default });
    EOSManager.api = new eosjs_1.Api({
        rpc: EOSManager.rpc,
        chainId,
        signatureProvider: EOSManager.signatureProvider,
        // Same deal here, type mismatch when there really shouldn't be.
        textDecoder: new util_1.TextDecoder(),
        textEncoder: new util_1.TextEncoder(),
    });
};
/**
 * Ensures our signature provider has the key in question, and if not, adds it.
 * @author Kevin Brown <github.com/thekevinbrown>
 * @param account Account to be unioned into the signature list.
 */
EOSManager.addSigningAccountIfMissing = (account) => {
    // If there are keys and signature provider doesn't have it, add it on in.
    if (account.publicKey && account.privateKey) {
        const nonLegacyPublicKey = eosjs_numeric_1.convertLegacyPublicKey(account.publicKey);
        if (!EOSManager.signatureProvider.keys.get(nonLegacyPublicKey)) {
            EOSManager.signatureProvider.keys.set(nonLegacyPublicKey, account.privateKey);
            EOSManager.signatureProvider.availableKeys.push(nonLegacyPublicKey);
        }
    }
};
/**
 * Executes a transaction against a connected EOSjs client
 * @author Kevin Brown <github.com/thekevinbrown>
 * @param transaction EOSIO transaction object
 * @param eos Connected EOSjs client
 * @param options Additional transaction options
 */
EOSManager.transact = (transaction, eos = EOSManager.api, options) => __awaiter(void 0, void 0, void 0, function* () {
    const flattenedOptions = Object.assign({ blocksBehind: 1, expireSeconds: 30 }, options);
    if (configManager_1.ConfigManager.debugTransactions || flattenedOptions.debug) {
        const calls = transaction.actions.map((action) => `${action.account}.${action.name}`);
        console.log(`========== Calling ${calls.join(', ')} ==========`);
        console.log('Transaction: ', JSON.stringify(transaction, null, 4));
        console.log('Options: ', options);
        console.log();
    }
    return yield eos.transact(transaction, flattenedOptions);
});

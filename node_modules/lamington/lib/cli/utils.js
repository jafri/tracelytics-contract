"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const Mocha = require("mocha");
const mkdirpCallback = require("mkdirp");
const rimrafCallback = require("rimraf");
const qrcode = require("qrcode-terminal");
const fs_1 = require("fs");
const globCallback = require("glob");
const path = require("path");
const util_1 = require("util");
const exists = util_1.promisify(fs_1.exists);
const glob = util_1.promisify(globCallback);
const mkdirp = util_1.promisify(mkdirpCallback);
const rimraf = util_1.promisify(rimrafCallback);
const writeFile = util_1.promisify(fs_1.writeFile);
// It's nice to give people proper stack traces when they have a problem with their code.
// Trace shows async traces, and Clarify removes internal Node entries.
// Source Map Support adds proper source map support so line numbers match up to the original TS code.
require("trace");
require("clarify");
Error.stackTraceLimit = 20;
const docker_cli_js_1 = require("docker-cli-js");
exports.docker = new docker_cli_js_1.Docker();
const eosManager_1 = require("../eosManager");
const utils_1 = require("../utils");
const contracts_1 = require("../contracts");
const configManager_1 = require("../configManager");
const spinner = require("./logIndicator");
/** @hidden Current working directory reference */
const WORKING_DIRECTORY = process.cwd();
/** @hidden Temporary docker resource directory */
const TEMP_DOCKER_DIRECTORY = path.join(__dirname, '.temp-docker');
/** @hidden Slowest Expected test duration */
const TEST_EXPECTED_DURATION = 2000;
/** @hidden Maximum test duration */
const TEST_TIMEOUT_DURATION = 10000;
/** @hidden Maximum number of EOS connection attempts before fail */
const MAX_CONNECTION_ATTEMPTS = 8;
/**
 * Extracts the version identifier from a string
 * @author Kevin Brown <github.com/thekevinbrown>
 * @returns Version identifier
 */
const versionFromUrl = (url) => {
    // Looks for strings in this format: `/v1.4.6/`
    const pattern = /\/(v\d+\.\d+\.\d+)\//g;
    const result = pattern.exec(url);
    // Handle result
    if (!result)
        throw new Error(`Could not extract version number from url: '${url}'`);
    return result[1];
};
/**
 * Constructs the name of the current Lamington Docker image
 * @author Kevin Brown <github.com/thekevinbrown>
 * @returns Docker image name
 */
const dockerImageName = () => __awaiter(void 0, void 0, void 0, function* () {
    yield configManager_1.ConfigManager.loadConfigFromDisk();
    return `lamington:eos.${versionFromUrl(configManager_1.ConfigManager.eos)}-cdt.${versionFromUrl(configManager_1.ConfigManager.cdt)}`;
});
/**
 * Determines if the docker image exists
 * @author Kevin Brown <github.com/thekevinbrown>
 * @returns Result of search
 */
exports.imageExists = () => __awaiter(void 0, void 0, void 0, function* () {
    // Fetch image name and check existence
    const result = yield exports.docker.command(`images ${yield dockerImageName()}`);
    return result.images.length > 0;
});
/**
 * Configures and builds the docker image
 * @author Kevin Brown <github.com/thekevinbrown>
 * @author Mitch Pierias <github.com/MitchPierias>
 */
exports.buildImage = () => __awaiter(void 0, void 0, void 0, function* () {
    // Log notification
    spinner.create('Building docker image');
    // Clear the docker directory if it exists.
    yield rimraf(TEMP_DOCKER_DIRECTORY);
    yield mkdirp(TEMP_DOCKER_DIRECTORY);
    // Write a Dockerfile so Docker knows what to build.
    yield writeFile(path.join(TEMP_DOCKER_DIRECTORY, 'Dockerfile'), `
		FROM ubuntu:18.04

		RUN apt-get update --fix-missing && apt-get install -y --no-install-recommends wget curl ca-certificates
		RUN wget ${configManager_1.ConfigManager.cdt} && apt-get install -y ./*.deb && rm -f *.deb
		RUN wget ${configManager_1.ConfigManager.eos} && apt-get install -y ./*.deb && rm -f *.deb
		RUN apt-get clean && rm -rf /tmp/* /var/tmp/* && rm -rf /var/lib/apt/lists/*
		`.replace(/\t/gm, ''));
    // Execute docker build process
    yield exports.docker.command(`build -t ${yield dockerImageName()} "${TEMP_DOCKER_DIRECTORY}"`);
    // Clean up after ourselves.
    yield rimraf(TEMP_DOCKER_DIRECTORY);
    spinner.end('Built docker image');
});
/**
 * Starts the Lamington container
 * @author Kevin Brown <github.com/thekevinbrown>
 */
exports.startContainer = () => __awaiter(void 0, void 0, void 0, function* () {
    yield exports.docker.command(`run
				--rm
				--name lamington
				-d
				-p 8888:8888
				-p 9876:9876
				--mount type=bind,src="${WORKING_DIRECTORY}",dst=/opt/eosio/bin/project
				--mount type=bind,src="${__dirname}/../scripts",dst=/opt/eosio/bin/scripts
				-w "/opt/eosio/bin/"
				${yield dockerImageName()}
				/bin/bash -c "./scripts/init_blockchain.sh"`
        .replace(/\n/gm, '')
        .replace(/\t/gm, ' '));
});
/**
 * Stops the current Lamington container
 * @author Kevin Brown <github.com/thekevinbrown>
 * @author Mitch Pierias <github.com/MitchPierias>
 * @returns Docker command promise
 */
exports.stopContainer = () => __awaiter(void 0, void 0, void 0, function* () {
    spinner.create('Stopping EOS Docker Container');
    try {
        yield exports.docker.command('stop lamington');
        spinner.end('Stopped EOS Docker Container');
    }
    catch (err) {
        spinner.fail(err);
    }
});
/**
 * Sleeps the process until the EOS instance is available
 * @author Kevin Brown <github.com/thekevinbrown>
 * @author Mitch Pierias <github.com/MitchPierias>
 * @returns Connection success or throws error
 */
exports.untilEosIsReady = (attempts = MAX_CONNECTION_ATTEMPTS) => __awaiter(void 0, void 0, void 0, function* () {
    // Begin logging
    spinner.create('Waiting for EOS');
    // Repeat attempts every second until threshold reached
    let attempt = 0;
    while (attempt < attempts) {
        attempt++;
        // Check EOS status
        if (yield exports.eosIsReady()) {
            spinner.end('EOS is ready');
            return true;
        }
        // Wait one second
        yield utils_1.sleep(1000);
    }
    // Failed to connect within attempt threshold
    spinner.fail(`Failed to connect with an EOS instance`);
    throw new Error(`Could not contact EOS after trying for ${attempts} second(s).`);
});
/**
 * Determines if EOS is available using the `get_info` query response
 * @author Kevin Brown <github.com/thekevinbrown>
 * @returns EOS instance availability
 */
exports.eosIsReady = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const info = yield axios_1.default.get('http://localhost:8888/v1/chain/get_info');
        return info && info.status === 200;
    }
    catch (error) {
        return false;
    }
});
/**
 * Pulls the EOSIO docker image if it doesn't exist and starts
 * a new EOSIO docker container
 * @author Kevin Brown <github.com/thekevinbrown>
 * @author Mitch Pierias <github.com/MitchPierias>
 */
exports.startEos = () => __awaiter(void 0, void 0, void 0, function* () {
    spinner.create('Starting EOS docker container');
    // Ensure an EOSIO build image exists
    if (!(yield exports.imageExists())) {
        console.log('--------------------------------------------------------------');
        console.log('Docker image does not yet exist. Building...');
        console.log('Note: This will take a few minutes but only happens once for each version of the EOS tools you use.');
        console.log();
        console.log(`We've prepared some hold music for you: https://youtu.be/6g4dkBF5anU`);
        console.log();
        qrcode.generate('https://youtu.be/6g4dkBF5anU');
        // Build EOSIO image
        yield exports.buildImage();
    }
    // Start EOSIO
    try {
        // Start the EOS docker container
        yield exports.startContainer();
        // Pause process until ready
        yield exports.untilEosIsReady();
        console.log('                                        \n\
==================================================== \n\
                                                     \n\
      EOS running, admin account created.            \n\
                                                     \n\
      RPC: http://localhost:8888                     \n\
	  Docker Container: lamington                    \n\
                                                     \n\
==================================================== \n');
        spinner.end('Started EOS docker container');
    }
    catch (error) {
        spinner.fail('Failed to start the EOS container');
        console.log(` --> ${error}`);
        process.exit(1);
    }
});
/**
 * Loads all test files and executes with Mocha
 * @author Kevin Brown <github.com/thekevinbrown>
 * @note This is where we should allow configuration over all files or specified files/folder
 */
exports.runTests = () => __awaiter(void 0, void 0, void 0, function* () {
    // Initialize the EOS connection manager
    eosManager_1.EOSManager.initWithDefaults();
    // Register ts-mocha if it's a Typescript project
    if (yield exists(path.join(WORKING_DIRECTORY, 'tsconfig.json'))) {
        require('ts-mocha');
    }
    // Register their .env file variables if they have one.
    if (yield exists(path.join(WORKING_DIRECTORY, '.env'))) {
        require('dotenv').config({ path: path.join(WORKING_DIRECTORY, '.env') });
    }
    // Find all existing test file paths
    const files = [
        // All ts and js files under the test folder get added.
        ...(yield glob('{test,tests}/**/*.{js,ts}')),
        // Any .test.ts, .test.js, .spec.ts, .spec.js files anywhere in the working tree
        // outside of node_modules get added.
        ...(yield glob('!(node_modules)/**/*.{test,spec}.{js,ts}')),
    ];
    // Instantiate a Mocha instance.
    const mocha = new Mocha();
    for (const testFile of files) {
        mocha.addFile(path.join(WORKING_DIRECTORY, testFile));
    }
    // Our tests are more like integration tests than unit tests. Taking two seconds is
    // pretty reasonable in our case and it's possible a successful test would take 10 seconds.
    mocha.slow(TEST_EXPECTED_DURATION);
    mocha.timeout(TEST_TIMEOUT_DURATION);
    // Run the tests.
    yield new Promise((resolve, reject) => mocha.run(failures => {
        if (failures)
            return reject(failures);
        return resolve();
    }));
});
/**
 * Finds and builds all C++ contracts
 * @author Kevin Brown <github.com/thekevinbrown>
 * @author Mitch Pierias <github.com/MitchPierias>
 * @param match Optional specific contract identifiers to build
 */
exports.buildAll = (match) => __awaiter(void 0, void 0, void 0, function* () {
    // Find all contract files
    const errors = [];
    let contracts = yield glob('!(node_modules)/**/*.cpp');
    // Cleanse ignored contracts
    contracts = filterMatches(onlyMatches(contracts, match || ['\\.cpp$']));
    if (contracts.length === 0) {
        console.error();
        console.error('Could not find any smart contracts to build.');
        process.exit(1);
    }
    // Log the batch building process
    console.log(`BUILDING ${contracts.length} SMART CONTRACT${contracts.length > 1 ? 'S' : ''}\n`);
    // Build each contract and handle errors
    for (const contract of contracts) {
        try {
            yield exports.build(contract);
        }
        catch (error) {
            errors.push({
                message: `Failed to compile contract ${contract}`,
                error,
            });
        }
    }
    // Report any caught errors
    if (errors.length > 0) {
        // Print each error message and source
        for (const error of errors)
            console.error(error.message, '\n', ' -> ', error.error);
        // Terminate the current process
        throw new Error(`${errors.length} contract${errors.length > 0 ? 's' : ''} failed to compile. Quitting.`);
    }
});
const onlyMatches = (paths, matches = []) => {
    return paths.filter(filePath => {
        return matches.reduce((result, str) => {
            const pattern = new RegExp(str, 'gi');
            return result || pattern.test(filePath);
        }, false);
    });
};
const filterMatches = (paths) => {
    return paths.filter(filePath => {
        return !configManager_1.ConfigManager.exclude.reduce((result, match) => {
            const pattern = new RegExp(match, 'gi');
            return result || pattern.test(filePath);
        }, false);
    });
};
/**
 * Resolves the path to file identifier.
 * This is the path without trailing file extension
 * @author Kevin Brown <github.com/thekevinbrown>
 * @note What happens when the input path contains no trailing extension?
 * @param filePath Path to file
 * @returns Identifier path
 */
exports.pathToIdentifier = (filePath) => filePath.substr(0, filePath.lastIndexOf('.'));
/**
 * Builds contract resources for contract at path
 * @author Kevin Brown <github.com/thekevinbrown>
 * @author Mitch Pierias <github.com/MitchPierias>
 * @param contractPath Local path to C++ contract file
 */
exports.build = (contractPath) => __awaiter(void 0, void 0, void 0, function* () {
    // Get the base filename from path and log status
    const basename = path.basename(contractPath, '.cpp');
    // Compile contract at path
    yield exports.compileContract(contractPath);
    // Generate Typescript definitions for contract
    spinner.create(`Generating type definitions`);
    try {
        yield contracts_1.generateTypes(exports.pathToIdentifier(contractPath));
        spinner.end(`Generated type definitions`);
    }
    catch (error) {
        spinner.fail(`Failed to generate type definitions`);
        console.log(` --> ${error.message}`);
    }
});
/**
 * Determines the output location for a contract based on the full path of its C++ file.
 * @author Kevin Brown <github.com/thekevinbrown>
 * @param contractPath Full path to C++ contract file
 * @returns Output path for contract compilation artefacts
 */
exports.outputPathForContract = (contractPath) => path.join(configManager_1.ConfigManager.outDir, 'compiled_contracts', path.dirname(contractPath));
/**
 * Compiles a C++ EOSIO smart contract at path
 * @author Kevin Brown <github.com/thekevinbrown>
 * @author Mitch Pierias <github.com/MitchPierias>
 * @param contractPath Full path to C++ contract file
 */
exports.compileContract = (contractPath) => __awaiter(void 0, void 0, void 0, function* () {
    // Begin logs
    spinner.create(`Compiling contract`);
    const basename = path.basename(contractPath, '.cpp');
    if (!(yield exists(contractPath))) {
        spinner.fail(`Couldn't locate contract at ${contractPath}. Are you sure used the correct contract identifier when trying to build the contract?`);
        throw new Error("Contract doesn't exist on disk.");
    }
    const outputPath = exports.outputPathForContract(contractPath);
    // Run the compile contract script inside our docker container.
    yield exports.docker
        .command(
    // Arg 1 is filename, arg 2 is contract name.
    `exec lamington /opt/eosio/bin/scripts/compile_contract.sh "/${path.join('opt', 'eosio', 'bin', 'project', contractPath)}" "${outputPath}" "${basename}"`)
        .catch(err => {
        spinner.fail('Failed to compile');
        console.log(` --> ${err}`);
        throw err;
    });
    // Notify build task completed
    spinner.end(`Compiled contract`);
});
